diff --git a/gcc/config/aarch64/aarch64.md b/gcc/config/aarch64/aarch64.md
index 385a669b9b3..329ff269ae7 100644
--- a/gcc/config/aarch64/aarch64.md
+++ b/gcc/config/aarch64/aarch64.md
@@ -565,74 +565,25 @@
 ;; Pipeline descriptions and scheduling
 ;; -------------------------------------------------------------------
 
-;; Processor types.
-(include "aarch64-tune.md")
 
 ;; Scheduling
-(include "../arm/cortex-a53.md")
-(include "../arm/cortex-a57.md")
-(include "../arm/exynos-m1.md")
-(include "falkor.md")
-(include "saphira.md")
-(include "thunderx.md")
-(include "../arm/xgene1.md")
-(include "thunderx2t99.md")
-(include "tsv110.md")
-(include "thunderx3t110.md")
 
 ;; -------------------------------------------------------------------
 ;; Jumps and other miscellaneous insns
 ;; -------------------------------------------------------------------
 
-(define_insn "aarch64_read_sysregdi"
-  [(set (match_operand:DI 0 "register_operand" "=r")
-	(unspec_volatile:DI [(match_operand 1 "aarch64_sysreg_string" "")]
-			    UNSPEC_SYSREG_RDI))]
-  ""
-  "mrs\t%x0, %1"
-)
-
-(define_insn "aarch64_read_sysregti"
-  [(set (match_operand:TI 0 "register_operand" "=r")
-    (unspec_volatile:TI [(match_operand 1 "aarch64_sysreg_string" "")]
-			UNSPEC_SYSREG_RTI))]
- "TARGET_D128"
- "mrrs\t%x0, %H0, %x1"
-)
-
-(define_insn "aarch64_write_sysregdi"
-  [(unspec_volatile:DI [(match_operand 0 "aarch64_sysreg_string" "")
-			(match_operand:DI 1 "register_operand" "rZ")]
-		       UNSPEC_SYSREG_WDI)]
+(define_insn "jump"
+  [(set (pc) (label_ref (match_operand 0 "" "")))]
   ""
-  "msr\t%0, %x1"
-)
+  "b\\t%l0"
+  [(set_attr "type" "branch")])
 
-(define_insn "aarch64_write_sysregti"
- [(unspec_volatile:TI [(match_operand 0 "aarch64_sysreg_string" "")
-		       (match_operand:TI 1 "register_operand" "r")]
-		      UNSPEC_SYSREG_WTI)]
- "TARGET_D128"
- "msrr\t%x0, %x1, %H1"
-)
 
 (define_insn "indirect_jump"
   [(set (pc) (match_operand:DI 0 "register_operand" "r"))]
   ""
-  {
-    output_asm_insn ("br\\t%0", operands);
-    return aarch64_sls_barrier (aarch64_harden_sls_retbr_p ());
-  }
-  [(set_attr "type" "branch")
-   (set_attr "sls_length" "retbr")]
-)
-
-(define_insn "jump"
-  [(set (pc) (label_ref (match_operand 0 "" "")))]
-  ""
-  "b\\t%l0"
-  [(set_attr "type" "branch")]
-)
+  "br\\t%0"
+  [(set_attr "type" "branch")])
 
 (define_expand "cbranch<mode>4"
   [(set (pc) (if_then_else (match_operator 0 "aarch64_comparison_operator"
@@ -672,201 +623,6 @@
   ""
   "")
 
-(define_insn "@ccmp<CC_ONLY:mode><GPI:mode>"
-  [(set (match_operand:CC_ONLY 1 "cc_register")
-	(if_then_else:CC_ONLY
-	  (match_operator 4 "aarch64_comparison_operator"
-	   [(match_operand 0 "cc_register")
-	    (const_int 0)])
-	  (compare:CC_ONLY
-	    (match_operand:GPI 2 "register_operand")
-	    (match_operand:GPI 3 "aarch64_ccmp_operand"))
-	  (unspec:CC_ONLY
-	    [(match_operand 5 "immediate_operand")]
-	    UNSPEC_NZCV)))]
-  ""
-  {@ [ cons: 2 , 3   ; attrs: type ]
-     [ r       , r   ; alus_sreg   ] ccmp\t%<w>2, %<w>3, %k5, %m4
-     [ r       , Uss ; alus_imm    ] ccmp\t%<w>2, %3, %k5, %m4
-     [ r       , Usn ; alus_imm    ] ccmn\t%<w>2, #%n3, %k5, %m4
-  }
-)
-
-(define_insn "@ccmp<CCFP_CCFPE:mode><GPF:mode>"
-  [(set (match_operand:CCFP_CCFPE 1 "cc_register" "")
-	(if_then_else:CCFP_CCFPE
-	  (match_operator 4 "aarch64_comparison_operator"
-	   [(match_operand 0 "cc_register" "")
-	    (const_int 0)])
-	  (compare:CCFP_CCFPE
-	    (match_operand:GPF 2 "register_operand" "w")
-	    (match_operand:GPF 3 "register_operand" "w"))
-	  (unspec:CCFP_CCFPE
-	    [(match_operand 5 "immediate_operand")]
-	    UNSPEC_NZCV)))]
-  "TARGET_FLOAT"
-  "fccmp<e>\\t%<s>2, %<s>3, %k5, %m4"
-  [(set_attr "type" "fccmp<s>")]
-)
-
-(define_insn "@ccmp<CC_ONLY:mode><GPI:mode>_rev"
-  [(set (match_operand:CC_ONLY 1 "cc_register")
-	(if_then_else:CC_ONLY
-	  (match_operator 4 "aarch64_comparison_operator"
-	   [(match_operand 0 "cc_register")
-	    (const_int 0)])
-	  (unspec:CC_ONLY
-	    [(match_operand 5 "immediate_operand")]
-	    UNSPEC_NZCV)
-	  (compare:CC_ONLY
-	    (match_operand:GPI 2 "register_operand")
-	    (match_operand:GPI 3 "aarch64_ccmp_operand"))))]
-  ""
-  {@ [ cons: 2 , 3   ; attrs: type ]
-     [ r       , r   ; alus_sreg   ] ccmp\t%<w>2, %<w>3, %k5, %M4
-     [ r       , Uss ; alus_imm    ] ccmp\t%<w>2, %3, %k5, %M4
-     [ r       , Usn ; alus_imm    ] ccmn\t%<w>2, #%n3, %k5, %M4
-  }
-)
-
-(define_insn "@ccmp<CCFP_CCFPE:mode><GPF:mode>_rev"
-  [(set (match_operand:CCFP_CCFPE 1 "cc_register" "")
-	(if_then_else:CCFP_CCFPE
-	  (match_operator 4 "aarch64_comparison_operator"
-	   [(match_operand 0 "cc_register" "")
-	    (const_int 0)])
-	  (unspec:CCFP_CCFPE
-	    [(match_operand 5 "immediate_operand")]
-	    UNSPEC_NZCV)
-	  (compare:CCFP_CCFPE
-	    (match_operand:GPF 2 "register_operand" "w")
-	    (match_operand:GPF 3 "register_operand" "w"))))]
-  "TARGET_FLOAT"
-  "fccmp<e>\\t%<s>2, %<s>3, %k5, %M4"
-  [(set_attr "type" "fccmp<s>")]
-)
-
-;; Expansion of signed mod by a power of 2 using CSNEG.
-;; For x0 % n where n is a power of 2 produce:
-;; negs   x1, x0
-;; and    x0, x0, #(n - 1)
-;; and    x1, x1, #(n - 1)
-;; csneg  x0, x0, x1, mi
-
-(define_expand "mod<mode>3"
-  [(match_operand:GPI 0 "register_operand")
-   (match_operand:GPI 1 "register_operand")
-   (match_operand:GPI 2 "const_int_operand")]
-  ""
-  {
-    HOST_WIDE_INT val = INTVAL (operands[2]);
-
-    if (val <= 0
-       || exact_log2 (val) <= 0
-       || !aarch64_bitmask_imm (val - 1, <MODE>mode))
-      FAIL;
-
-    rtx mask = GEN_INT (val - 1);
-
-    /* In the special case of x0 % 2 we can do the even shorter:
-	cmp    x0, xzr
-	and    x0, x0, 1
-	cneg   x0, x0, lt.  */
-    if (val == 2)
-      {
-	rtx masked = gen_reg_rtx (<MODE>mode);
-	rtx ccreg = aarch64_gen_compare_reg (LT, operands[1], const0_rtx);
-	emit_insn (gen_and<mode>3 (masked, operands[1], mask));
-	rtx x = gen_rtx_LT (VOIDmode, ccreg, const0_rtx);
-	emit_insn (gen_csneg3<mode>_insn (operands[0], x, masked, masked));
-	DONE;
-      }
-
-    rtx neg_op = gen_reg_rtx (<MODE>mode);
-    rtx_insn *insn = emit_insn (gen_neg<mode>2_compare0 (neg_op, operands[1]));
-
-    /* Extract the condition register and mode.  */
-    rtx cmp = XVECEXP (PATTERN (insn), 0, 0);
-    rtx cc_reg = SET_DEST (cmp);
-    rtx cond = gen_rtx_GE (VOIDmode, cc_reg, const0_rtx);
-
-    rtx masked_pos = gen_reg_rtx (<MODE>mode);
-    emit_insn (gen_and<mode>3 (masked_pos, operands[1], mask));
-
-    rtx masked_neg = gen_reg_rtx (<MODE>mode);
-    emit_insn (gen_and<mode>3 (masked_neg, neg_op, mask));
-
-    emit_insn (gen_csneg3<mode>_insn (operands[0], cond,
-				       masked_neg, masked_pos));
-    DONE;
-  }
-)
-
-(define_insn "condjump"
-  [(set (pc) (if_then_else (match_operator 0 "aarch64_comparison_operator"
-			    [(match_operand 1 "cc_register" "") (const_int 0)])
-			   (label_ref (match_operand 2 "" ""))
-			   (pc)))]
-  ""
-  {
-    /* GCC's traditional style has been to use "beq" instead of "b.eq", etc.,
-       but the "." is required for SVE conditions.  */
-    bool use_dot_p = GET_MODE (operands[1]) == CC_NZCmode;
-    if (get_attr_length (insn) == 8)
-      return aarch64_gen_far_branch (operands, 2, "Lbcond",
-				     use_dot_p ? "b.%M0\\t" : "b%M0\\t");
-    else
-      return use_dot_p ? "b.%m0\\t%l2" : "b%m0\\t%l2";
-  }
-  [(set_attr "type" "branch")
-   (set (attr "length")
-	(if_then_else (and (ge (minus (match_dup 2) (pc)) (const_int -1048576))
-			   (lt (minus (match_dup 2) (pc)) (const_int 1048572)))
-		      (const_int 4)
-		      (const_int 8)))
-   (set (attr "far_branch")
-	(if_then_else (and (ge (minus (match_dup 2) (pc)) (const_int -1048576))
-			   (lt (minus (match_dup 2) (pc)) (const_int 1048572)))
-		      (const_int 0)
-		      (const_int 1)))]
-)
-
-;; For a 24-bit immediate CST we can optimize the compare for equality
-;; and branch sequence from:
-;; 	mov	x0, #imm1
-;; 	movk	x0, #imm2, lsl 16 /* x0 contains CST.  */
-;; 	cmp	x1, x0
-;; 	b<ne,eq> .Label
-;; into the shorter:
-;; 	sub	x0, x1, #(CST & 0xfff000)
-;; 	subs	x0, x0, #(CST & 0x000fff)
-;; 	b<ne,eq> .Label
-(define_insn_and_split "*compare_condjump<GPI:mode>"
-  [(set (pc) (if_then_else (EQL
-			      (match_operand:GPI 0 "register_operand" "r")
-			      (match_operand:GPI 1 "aarch64_imm24" "n"))
-			   (label_ref:P (match_operand 2 "" ""))
-			   (pc)))]
-  "!aarch64_move_imm (INTVAL (operands[1]), <GPI:MODE>mode)
-   && !aarch64_plus_operand (operands[1], <GPI:MODE>mode)
-   && !reload_completed"
-  "#"
-  "&& true"
-  [(const_int 0)]
-  {
-    HOST_WIDE_INT lo_imm = UINTVAL (operands[1]) & 0xfff;
-    HOST_WIDE_INT hi_imm = UINTVAL (operands[1]) & 0xfff000;
-    rtx tmp = gen_reg_rtx (<GPI:MODE>mode);
-    emit_insn (gen_add<GPI:mode>3 (tmp, operands[0], GEN_INT (-hi_imm)));
-    emit_insn (gen_add<GPI:mode>3_compare0 (tmp, tmp, GEN_INT (-lo_imm)));
-    rtx cc_reg = gen_rtx_REG (CC_NZmode, CC_REGNUM);
-    rtx cmp_rtx = gen_rtx_fmt_ee (<EQL:CMP>, <GPI:MODE>mode,
-				  cc_reg, const0_rtx);
-    emit_jump_insn (gen_condjump (cmp_rtx, cc_reg, operands[2]));
-    DONE;
-  }
-)
-
 (define_expand "casesi"
   [(match_operand:SI 0 "register_operand")	; Index
    (match_operand:SI 1 "const_int_operand")	; Lower bound
@@ -953,48 +709,6 @@
   [(set_attr "type" "no_insn")]
 )
 
-(define_insn "prefetch"
-  [(prefetch (match_operand:DI 0 "aarch64_prefetch_operand" "Dp")
-            (match_operand:QI 1 "const_int_operand" "")
-            (match_operand:QI 2 "const_int_operand" ""))]
-  ""
-  {
-    const char * pftype[2][4] =
-    {
-      {"prfm\\tPLDL1STRM, %0",
-       "prfm\\tPLDL3KEEP, %0",
-       "prfm\\tPLDL2KEEP, %0",
-       "prfm\\tPLDL1KEEP, %0"},
-      {"prfm\\tPSTL1STRM, %0",
-       "prfm\\tPSTL3KEEP, %0",
-       "prfm\\tPSTL2KEEP, %0",
-       "prfm\\tPSTL1KEEP, %0"},
-    };
-
-    int locality = INTVAL (operands[2]);
-
-    gcc_assert (IN_RANGE (locality, 0, 3));
-
-    /* PRFM accepts the same addresses as a 64-bit LDR so wrap
-       the address into a DImode MEM so that aarch64_print_operand knows
-       how to print it.  */
-    operands[0] = gen_rtx_MEM (DImode, operands[0]);
-    return pftype[INTVAL(operands[1])][locality];
-  }
-  [(set_attr "type" "load_4")]
-)
-
-(define_insn "aarch64_pldx"
-  [(unspec [(match_operand 0 "" "")
-	    (match_operand:DI 1 "aarch64_prefetch_operand" "Dp")] UNSPEC_PLDX)]
-  ""
-  {
-    operands[1] = gen_rtx_MEM (DImode, operands[1]);
-    return "prfm\\t%0, %1";
-  }
-  [(set_attr "type" "load_4")]
-)
-
 (define_insn "trap"
   [(trap_if (const_int 1) (const_int 8))]
   ""
@@ -1509,17 +1223,6 @@
   }
 )
 
-(define_insn "insv_imm<mode>"
-  [(set (zero_extract:GPI (match_operand:GPI 0 "register_operand" "+r")
-			  (const_int 16)
-			  (match_operand:GPI 1 "const_int_operand" "n"))
-	(match_operand:GPI 2 "const_int_operand" "n"))]
-  "UINTVAL (operands[1]) < GET_MODE_BITSIZE (<MODE>mode)
-   && UINTVAL (operands[1]) % 16 == 0"
-  "movk\\t%<w>0, %X2, lsl %1"
-  [(set_attr "type" "mov_imm")]
-)
-
 ;; Match MOVK as a normal AND and IOR operation.
 (define_insn "aarch64_movk<mode>"
   [(set (match_operand:GPI 0 "register_operand" "=r")
@@ -1742,139 +1445,6 @@
   }
 )
 
-(define_expand "aarch64_cpymemdi"
-  [(parallel
-     [(set (match_operand 2) (const_int 0))
-      (clobber (match_dup 3))
-      (clobber (match_dup 4))
-      (clobber (reg:CC CC_REGNUM))
-      (set (match_operand 0)
-	   (unspec:BLK [(match_operand 1) (match_dup 2)] UNSPEC_CPYMEM))])]
-  "TARGET_MOPS"
-  {
-    operands[3] = XEXP (operands[0], 0);
-    operands[4] = XEXP (operands[1], 0);
-  }
-)
-
-(define_insn "*aarch64_cpymemdi"
-  [(set (match_operand:DI 2 "register_operand" "+&r") (const_int 0))
-   (clobber (match_operand:DI 0 "register_operand" "+&r"))
-   (clobber (match_operand:DI 1 "register_operand" "+&r"))
-   (clobber (reg:CC CC_REGNUM))
-   (set (mem:BLK (match_dup 0))
-        (unspec:BLK [(mem:BLK (match_dup 1)) (match_dup 2)] UNSPEC_CPYMEM))]
-  "TARGET_MOPS"
-  "cpyfp\t[%x0]!, [%x1]!, %x2!\;cpyfm\t[%x0]!, [%x1]!, %x2!\;cpyfe\t[%x0]!, [%x1]!, %x2!"
-  [(set_attr "length" "12")]
-)
-
-;; 0 is dst
-;; 1 is src
-;; 2 is size of copy in bytes
-;; 3 is alignment
-
-(define_expand "cpymemdi"
-  [(match_operand:BLK 0 "memory_operand")
-   (match_operand:BLK 1 "memory_operand")
-   (match_operand:DI 2 "general_operand")
-   (match_operand:DI 3 "immediate_operand")]
-   ""
-{
-  if (aarch64_expand_cpymem (operands, false))
-    DONE;
-  FAIL;
-}
-)
-
-(define_expand "aarch64_movmemdi"
-  [(parallel
-     [(set (match_operand 2) (const_int 0))
-      (clobber (match_dup 3))
-      (clobber (match_dup 4))
-      (clobber (reg:CC CC_REGNUM))
-      (set (match_operand 0)
-	   (unspec:BLK [(match_operand 1) (match_dup 2)] UNSPEC_MOVMEM))])]
-  "TARGET_MOPS"
-  {
-    operands[3] = XEXP (operands[0], 0);
-    operands[4] = XEXP (operands[1], 0);
-  }
-)
-
-(define_insn "*aarch64_movmemdi"
-  [(parallel [
-   (set (match_operand:DI 2 "register_operand" "+&r") (const_int 0))
-   (clobber (match_operand:DI 0 "register_operand" "+&r"))
-   (clobber (match_operand:DI 1 "register_operand" "+&r"))
-   (clobber (reg:CC CC_REGNUM))
-   (set (mem:BLK (match_dup 0))
-        (unspec:BLK [(mem:BLK (match_dup 1)) (match_dup 2)] UNSPEC_MOVMEM))])]
- "TARGET_MOPS"
- "cpyp\t[%x0]!, [%x1]!, %x2!\;cpym\t[%x0]!, [%x1]!, %x2!\;cpye\t[%x0]!, [%x1]!, %x2!"
- [(set_attr "length" "12")]
-)
-
-;; 0 is dst
-;; 1 is src
-;; 2 is size of copy in bytes
-;; 3 is alignment
-
-(define_expand "movmemdi"
-  [(match_operand:BLK 0 "memory_operand")
-   (match_operand:BLK 1 "memory_operand")
-   (match_operand:DI 2 "general_operand")
-   (match_operand:DI 3 "immediate_operand")]
-   ""
-{
-  if (aarch64_expand_cpymem (operands, true))
-    DONE;
-  FAIL;
-}
-)
-
-(define_expand "aarch64_setmemdi"
-  [(parallel
-     [(set (match_operand 2) (const_int 0))
-      (clobber (match_dup 3))
-      (clobber (reg:CC CC_REGNUM))
-      (set (match_operand 0)
-	   (unspec:BLK [(match_operand 1)
-			(match_dup 2)] UNSPEC_SETMEM))])]
-  "TARGET_MOPS"
-  {
-    operands[3] = XEXP (operands[0], 0);
-  }
-)
-
-(define_insn "*aarch64_setmemdi"
-  [(set (match_operand:DI 2 "register_operand" "+&r") (const_int 0))
-   (clobber (match_operand:DI 0 "register_operand" "+&r"))
-   (clobber (reg:CC CC_REGNUM))
-   (set (mem:BLK (match_dup 0))
-        (unspec:BLK [(match_operand:QI 1 "aarch64_reg_or_zero" "rZ")
-		     (match_dup 2)] UNSPEC_SETMEM))]
-  "TARGET_MOPS"
-  "setp\t[%x0]!, %x2!, %x1\;setm\t[%x0]!, %x2!, %x1\;sete\t[%x0]!, %x2!, %x1"
-  [(set_attr "length" "12")]
-)
-
-;; 0 is dst
-;; 1 is val
-;; 2 is size of copy in bytes
-;; 3 is alignment
-(define_expand "setmemdi"
-  [(set (match_operand:BLK 0 "memory_operand")     ;; Dest
-        (match_operand:QI  2 "nonmemory_operand")) ;; Value
-   (use (match_operand:DI  1 "general_operand")) ;; Length
-   (match_operand          3 "immediate_operand")] ;; Align
- ""
- {
-  if (aarch64_expand_setmem (operands))
-    DONE;
-
-  FAIL;
-})
 
 (define_insn "*load_pair_<ldst_sz>"
   [(set (match_operand:GPI 0 "aarch64_ldp_reg_operand")
@@ -1962,302 +1532,6 @@
   }
 )
 
-;; q-register variant of the above
-(define_insn "*loadwb_post_pair_16"
-  [(set (match_operand 0 "pmode_register_operand" "=rk")
-	(match_operator 7 "pmode_plus_operator" [
-	  (match_operand 1 "pmode_register_operand" "0")
-	  (match_operand 4 "const_int_operand")]))
-   (set (match_operand:TI 2 "aarch64_ldp_reg_operand" "=w")
-	(match_operator 5 "memory_operand" [(match_dup 1)]))
-   (set (match_operand:TI 3 "aarch64_ldp_reg_operand" "=w")
-	(match_operator 6 "memory_operand"
-	  [(match_operator 8 "pmode_plus_operator" [
-	     (match_dup 1)
-	     (const_int 16)])]))]
-  "TARGET_FLOAT
-   && aarch64_mem_pair_offset (operands[4], TImode)"
-  "ldp\t%q2, %q3, [%1], %4"
-  [(set_attr "type" "neon_ldp_q")]
-)
-
-;; Load pair with pre-index writeback.
-(define_insn "*loadwb_pre_pair_<ldst_sz>"
-  [(set (match_operand 0 "pmode_register_operand")
-	(match_operator 8 "pmode_plus_operator" [
-	  (match_operand 1 "pmode_register_operand")
-	  (match_operand 4 "const_int_operand")]))
-   (set (match_operand:GPI 2 "aarch64_ldp_reg_operand")
-	(match_operator 6 "memory_operand" [
-	  (match_operator 9 "pmode_plus_operator" [
-	    (match_dup 1)
-	    (match_dup 4)
-	  ])]))
-   (set (match_operand:GPI 3 "aarch64_ldp_reg_operand")
-	(match_operator 7 "memory_operand" [
-	  (match_operator 10 "pmode_plus_operator" [
-	     (match_dup 1)
-	     (match_operand 5 "const_int_operand")
-	  ])]))]
-  "aarch64_mem_pair_offset (operands[4], <MODE>mode)
-   && known_eq (INTVAL (operands[5]),
-		INTVAL (operands[4]) + GET_MODE_SIZE (<MODE>mode))"
-  {@ [cons: =&0, 1, =2, =3; attrs: type     ]
-     [       rk, 0,  r,  r; load_<ldpstp_sz>] ldp\t%<w>2, %<w>3, [%0, %4]!
-     [       rk, 0,  w,  w; neon_load1_2reg ] ldp\t%<v>2, %<v>3, [%0, %4]!
-  }
-)
-
-;; q-register variant of the above
-(define_insn "*loadwb_pre_pair_16"
-  [(set (match_operand 0 "pmode_register_operand" "=&rk")
-	(match_operator 8 "pmode_plus_operator" [
-	  (match_operand 1 "pmode_register_operand" "0")
-	  (match_operand 4 "const_int_operand")]))
-   (set (match_operand:TI 2 "aarch64_ldp_reg_operand" "=w")
-	(match_operator 6 "memory_operand" [
-	  (match_operator 9 "pmode_plus_operator" [
-	    (match_dup 1)
-	    (match_dup 4)
-	  ])]))
-   (set (match_operand:TI 3 "aarch64_ldp_reg_operand" "=w")
-	(match_operator 7 "memory_operand" [
-	  (match_operator 10 "pmode_plus_operator" [
-	     (match_dup 1)
-	     (match_operand 5 "const_int_operand")
-	  ])]))]
-  "TARGET_FLOAT
-   && aarch64_mem_pair_offset (operands[4], TImode)
-   && known_eq (INTVAL (operands[5]), INTVAL (operands[4]) + 16)"
-  "ldp\t%q2, %q3, [%0, %4]!"
-  [(set_attr "type" "neon_ldp_q")]
-)
-
-;; Store pair with pre-index writeback.  This is primarily used in function
-;; prologues.
-(define_insn "*storewb_pre_pair_<ldst_sz>"
-  [(set (match_operand 0 "pmode_register_operand")
-	(match_operator 6 "pmode_plus_operator" [
-	  (match_operand 1 "pmode_register_operand")
-	  (match_operand 4 "const_int_operand")
-	]))
-   (set (match_operator:GPI 7 "aarch64_mem_pair_operator" [
-	  (match_operator 8 "pmode_plus_operator" [
-	    (match_dup 0)
-	    (match_dup 4)
-	  ])])
-	(match_operand:GPI 2 "aarch64_stp_reg_operand"))
-   (set (match_operator:GPI 9 "aarch64_mem_pair_operator" [
-	  (match_operator 10 "pmode_plus_operator" [
-	    (match_dup 0)
-	    (match_operand 5 "const_int_operand")
-	  ])])
-	(match_operand:GPI 3 "aarch64_stp_reg_operand"))]
-  "aarch64_mem_pair_offset (operands[4], <MODE>mode)
-   && known_eq (INTVAL (operands[5]),
-		INTVAL (operands[4]) + GET_MODE_SIZE (<MODE>mode))
-   && !reg_overlap_mentioned_p (operands[0], operands[2])
-   && !reg_overlap_mentioned_p (operands[0], operands[3])"
-  {@ [cons: =&0, 1,   2,   3; attrs: type      ]
-     [       rk, 0, rYZ, rYZ; store_<ldpstp_sz>] stp\t%<w>2, %<w>3, [%0, %4]!
-     [       rk, 0,   w,   w; neon_store1_2reg ] stp\t%<v>2, %<v>3, [%0, %4]!
-  }
-)
-
-;; q-register variant of the above.
-(define_insn "*storewb_pre_pair_16"
-  [(set (match_operand 0 "pmode_register_operand" "=&rk")
-	(match_operator 6 "pmode_plus_operator" [
-	  (match_operand 1 "pmode_register_operand" "0")
-	  (match_operand 4 "const_int_operand")
-	]))
-   (set (match_operator:TI 7 "aarch64_mem_pair_operator" [
-	  (match_operator 8 "pmode_plus_operator" [
-	    (match_dup 0)
-	    (match_dup 4)
-	  ])])
-	(match_operand:TI 2 "aarch64_ldp_reg_operand" "w"))
-   (set (match_operator:TI 9 "aarch64_mem_pair_operator" [
-	  (match_operator 10 "pmode_plus_operator" [
-	    (match_dup 0)
-	    (match_operand 5 "const_int_operand")
-	  ])])
-	(match_operand:TI 3 "aarch64_ldp_reg_operand" "w"))]
-  "TARGET_FLOAT
-   && aarch64_mem_pair_offset (operands[4], TImode)
-   && known_eq (INTVAL (operands[5]), INTVAL (operands[4]) + 16)
-   && !reg_overlap_mentioned_p (operands[0], operands[2])
-   && !reg_overlap_mentioned_p (operands[0], operands[3])"
-  "stp\\t%q2, %q3, [%0, %4]!"
-  [(set_attr "type" "neon_stp_q")]
-)
-
-;; Store pair with post-index writeback.
-(define_insn "*storewb_post_pair_<ldst_sz>"
-  [(set (match_operand 0 "pmode_register_operand")
-	(match_operator 5 "pmode_plus_operator" [
-	  (match_operand 1 "pmode_register_operand")
-	  (match_operand 4 "const_int_operand")
-	]))
-   (set (match_operator:GPI 6 "aarch64_mem_pair_operator" [(match_dup 1)])
-	(match_operand 2 "aarch64_stp_reg_operand"))
-   (set (match_operator:GPI 7 "aarch64_mem_pair_operator" [
-	  (match_operator 8 "pmode_plus_operator" [
-	    (match_dup 0)
-	    (const_int <ldst_sz>)
-	  ])])
-	(match_operand 3 "aarch64_stp_reg_operand"))]
-  "aarch64_mem_pair_offset (operands[4], <MODE>mode)
-   && !reg_overlap_mentioned_p (operands[0], operands[2])
-   && !reg_overlap_mentioned_p (operands[0], operands[3])"
-  {@ [cons: =0, 1,   2,   3; attrs: type      ]
-     [      rk, 0, rYZ, rYZ; store_<ldpstp_sz>] stp\t%<w>2, %<w>3, [%0], %4
-     [      rk, 0,   w,   w; neon_store1_2reg ] stp\t%<v>2, %<v>3, [%0], %4
-  }
-)
-
-;; Store pair with post-index writeback.
-(define_insn "*storewb_post_pair_16"
-  [(set (match_operand 0 "pmode_register_operand" "=rk")
-	(match_operator 5 "pmode_plus_operator" [
-	  (match_operand 1 "pmode_register_operand" "0")
-	  (match_operand 4 "const_int_operand")
-	]))
-   (set (match_operator:TI 6 "aarch64_mem_pair_operator" [(match_dup 1)])
-	(match_operand:TI 2 "aarch64_ldp_reg_operand" "w"))
-   (set (match_operator:TI 7 "aarch64_mem_pair_operator" [
-	  (match_operator 8 "pmode_plus_operator" [
-	    (match_dup 0)
-	    (const_int 16)
-	  ])])
-	(match_operand:TI 3 "aarch64_ldp_reg_operand" "w"))]
-  "TARGET_FLOAT
-   && aarch64_mem_pair_offset (operands[4], TImode)
-   && !reg_overlap_mentioned_p (operands[0], operands[2])
-   && !reg_overlap_mentioned_p (operands[0], operands[3])"
-  "stp\t%q2, %q3, [%0], %4"
-  [(set_attr "type" "neon_stp_q")]
-)
-
-;; -------------------------------------------------------------------
-;; Sign/Zero extension
-;; -------------------------------------------------------------------
-
-(define_expand "<optab>sidi2"
-  [(set (match_operand:DI 0 "register_operand")
-	(ANY_EXTEND:DI (match_operand:SI 1 "nonimmediate_operand")))]
-  ""
-)
-
-(define_insn "*extendsidi2_aarch64"
-  [(set (match_operand:DI 0 "register_operand")
-        (sign_extend:DI (match_operand:SI 1 "nonimmediate_operand")))]
-  ""
-  {@ [ cons: =0 , 1 ; attrs: type ]
-     [ r        , r ; extend      ] sxtw\t%0, %w1
-     [ r        , m ; load_4      ] ldrsw\t%0, %1
-  }
-)
-
-(define_insn "*load_pair_extendsidi2_aarch64"
-  [(set (match_operand:DI 0 "register_operand" "=r")
-	(sign_extend:DI (unspec:SI [
-	  (match_operand:V2x4QI 1 "aarch64_mem_pair_lanes_operand" "Umn")
-	] UNSPEC_LDP_FST)))
-   (set (match_operand:DI 2 "register_operand" "=r")
-	(sign_extend:DI (unspec:SI [
-	  (match_dup 1)
-	] UNSPEC_LDP_SND)))]
-  ""
-  "ldpsw\\t%0, %2, %y1"
-  [(set_attr "type" "load_8")]
-)
-
-(define_insn "*zero_extendsidi2_aarch64"
-  [(set (match_operand:DI 0 "register_operand")
-        (zero_extend:DI (match_operand:SI 1 "nonimmediate_operand")))]
-  ""
-  {@ [ cons: =0 , 1 ; attrs: type , arch ]
-     [ r        , r ; mov_reg     , *    ] uxtw\t%0, %w1
-     [ r        , m ; load_4      , *    ] ldr\t%w0, %1
-     [ w        , r ; f_mcr       , fp   ] fmov\t%s0, %w1
-     [ w        , m ; f_loads     , fp   ] ldr\t%s0, %1
-     [ r        , w ; f_mrc       , fp   ] fmov\t%w0, %s1
-     [ w        , w ; fmov        , fp   ] fmov\t%s0, %s1
-  }
-)
-
-(define_insn "*load_pair_zero_extendsidi2_aarch64"
-  [(set (match_operand:DI 0 "register_operand")
-	(zero_extend:DI (unspec:SI [
-	  (match_operand:V2x4QI 1 "aarch64_mem_pair_lanes_operand")
-	] UNSPEC_LDP_FST)))
-   (set (match_operand:DI 2 "register_operand")
-	(zero_extend:DI (unspec:SI [
-	  (match_dup 1)
-	] UNSPEC_LDP_SND)))]
-  ""
-  {@ [ cons: =0 , 1   , =2; attrs: type    , arch]
-     [ r	, Umn , r ; load_8	   , *   ] ldp\t%w0, %w2, %y1
-     [ w	, Umn , w ; neon_load1_2reg, fp  ] ldp\t%s0, %s2, %y1
-  }
-)
-
-(define_expand "<ANY_EXTEND:optab><SHORT:mode><GPI:mode>2"
-  [(set (match_operand:GPI 0 "register_operand")
-        (ANY_EXTEND:GPI (match_operand:SHORT 1 "nonimmediate_operand")))]
-  ""
-)
-
-(define_insn "*extend<SHORT:mode><GPI:mode>2_aarch64"
-  [(set (match_operand:GPI 0 "register_operand")
-        (sign_extend:GPI (match_operand:SHORT 1 "nonimmediate_operand")))]
-  ""
-  {@ [ cons: =0 , 1 ; attrs: type , arch ]
-     [ r        , r ; extend      , *    ] sxt<SHORT:size>\t%<GPI:w>0, %w1
-     [ r        , m ; load_4      , *    ] ldrs<SHORT:size>\t%<GPI:w>0, %1
-     [ r        , w ; neon_to_gp  , fp   ] smov\t%<GPI:w>0, %1.<SHORT:size>[0]
-  }
-)
-
-(define_insn "*zero_extend<SHORT:mode><GPI:mode>2_aarch64"
-  [(set (match_operand:GPI 0 "register_operand")
-        (zero_extend:GPI (match_operand:SHORT 1 "nonimmediate_operand")))]
-  ""
-  {@ [ cons: =0 , 1 ; attrs: type , arch ]
-     [ r        , r ; logic_imm   , *    ] and\t%<GPI:w>0, %<GPI:w>1, <SHORT:short_mask>
-     [ r        , m ; load_4      , *    ] ldr<SHORT:size>\t%w0, %1
-     [ w        , m ; f_loads     , fp   ] ldr\t%<SHORT:size>0, %1
-     [ r        , w ; neon_to_gp  , fp   ] umov\t%w0, %1.<SHORT:size>[0]
-  }
-)
-
-(define_expand "<optab>qihi2"
-  [(set (match_operand:HI 0 "register_operand")
-        (ANY_EXTEND:HI (match_operand:QI 1 "nonimmediate_operand")))]
-  ""
-)
-
-(define_insn "*extendqihi2_aarch64"
-  [(set (match_operand:HI 0 "register_operand")
-	(sign_extend:HI (match_operand:QI 1 "nonimmediate_operand")))]
-  ""
-  {@ [ cons: =0 , 1 ; attrs: type ]
-     [ r        , r ; extend      ] sxtb\t%w0, %w1
-     [ r        , m ; load_4      ] ldrsb\t%w0, %1
-  }
-)
-
-(define_insn "*zero_extendqihi2_aarch64"
-  [(set (match_operand:HI 0 "register_operand")
-	(zero_extend:HI (match_operand:QI 1 "nonimmediate_operand")))]
-  ""
-  {@ [ cons: =0 , 1 ; attrs: type ]
-     [ r        , r ; logic_imm   ] and\t%w0, %w1, 255
-     [ r        , m ; load_4      ] ldrb\t%w0, %1
-  }
-)
-
 ;; -------------------------------------------------------------------
 ;; Simple arithmetic
 ;; -------------------------------------------------------------------
@@ -2319,22 +1593,6 @@
   ;; The "alu_imm" types for INC/DEC and ADDVL/ADDPL are just placeholders.
 )
 
-;; zero_extend version of above
-(define_insn "*addsi3_aarch64_uxtw"
-  [(set
-    (match_operand:DI 0 "register_operand")
-    (zero_extend:DI
-     (plus:SI (match_operand:SI 1 "register_operand")
-	      (match_operand:SI 2 "aarch64_pluslong_operand"))))]
-  ""
-  {@ [ cons: =0 , 1   , 2   ; attrs: type ]
-     [ rk       , %rk , I   ; alu_imm     ] add\t%w0, %w1, %2
-     [ rk       , rk  , r   ; alu_sreg    ] add\t%w0, %w1, %w2
-     [ rk       , rk  , J   ; alu_imm     ] sub\t%w0, %w1, #%n2
-     [ r        , rk  , Uaa ; multiple    ] #
-  }
-)
-
 ;; If there's a free register, and we can load the constant with a
 ;; single instruction, do so.  This has a chance to improve scheduling.
 (define_peephole2
@@ -2760,8 +2018,8 @@
 (define_insn "*adds_<optab><ALLX:mode>_shift_<GPI:mode>"
   [(set (reg:CC_NZ CC_REGNUM)
 	(compare:CC_NZ
-	 (plus:GPI (ashift:GPI 
-		    (ANY_EXTEND:GPI 
+	 (plus:GPI (ashift:GPI
+		    (ANY_EXTEND:GPI
 		     (match_operand:ALLX 1 "register_operand" "r"))
 		    (match_operand 2 "aarch64_imm3" "Ui3"))
 		   (match_operand:GPI 3 "register_operand" "rk"))
@@ -2779,7 +2037,7 @@
   [(set (reg:CC_NZ CC_REGNUM)
 	(compare:CC_NZ
 	 (minus:GPI (match_operand:GPI 1 "register_operand" "rk")
-		    (ashift:GPI 
+		    (ashift:GPI
 		     (ANY_EXTEND:GPI
 		      (match_operand:ALLX 2 "register_operand" "r"))
 		     (match_operand 3 "aarch64_imm3" "Ui3")))
@@ -4310,102 +3568,6 @@
   [(set_attr "type" "csel")]
 )
 
-(define_insn "cstore<mode>_neg"
-  [(set (match_operand:ALLI 0 "register_operand" "=r")
-	(neg:ALLI (match_operator:ALLI 1 "aarch64_comparison_operator_mode"
-		  [(match_operand 2 "cc_register" "") (const_int 0)])))]
-  ""
-  "csetm\\t%<w>0, %m1"
-  [(set_attr "type" "csel")]
-)
-
-;; zero_extend version of the above
-(define_insn "*cstoresi_neg_uxtw"
-  [(set (match_operand:DI 0 "register_operand" "=r")
-	(zero_extend:DI
-	 (neg:SI (match_operator:SI 1 "aarch64_comparison_operator_mode"
-		  [(match_operand 2 "cc_register" "") (const_int 0)]))))]
-  ""
-  "csetm\\t%w0, %m1"
-  [(set_attr "type" "csel")]
-)
-
-(define_expand "cmov<mode>6"
-  [(set (match_operand:GPI 0 "register_operand")
-	(if_then_else:GPI
-	 (match_operator 1 "aarch64_comparison_operator"
-	  [(match_operand:GPI 2 "register_operand")
-	   (match_operand:GPI 3 "aarch64_plus_operand")])
-	 (match_operand:GPI 4 "register_operand")
-	 (match_operand:GPI 5 "register_operand")))]
-  ""
-  "
-  operands[2] = aarch64_gen_compare_reg (GET_CODE (operands[1]), operands[2],
-				      operands[3]);
-  operands[3] = const0_rtx;
-  "
-)
-
-(define_expand "cmov<mode>6"
-  [(set (match_operand:GPF 0 "register_operand")
-	(if_then_else:GPF
-	 (match_operator 1 "aarch64_comparison_operator"
-	  [(match_operand:GPF 2 "register_operand")
-	   (match_operand:GPF 3 "aarch64_fp_compare_operand")])
-	 (match_operand:GPF 4 "register_operand")
-	 (match_operand:GPF 5 "register_operand")))]
-  ""
-  "
-  operands[2] = aarch64_gen_compare_reg (GET_CODE (operands[1]), operands[2],
-				      operands[3]);
-  operands[3] = const0_rtx;
-  "
-)
-
-(define_insn "*cmov<mode>_insn"
-  [(set (match_operand:ALLI 0 "register_operand")
-	(if_then_else:ALLI
-	 (match_operator 1 "aarch64_comparison_operator"
-	  [(match_operand 2 "cc_register") (const_int 0)])
-	 (match_operand:ALLI 3 "aarch64_reg_zero_or_m1_or_1")
-	 (match_operand:ALLI 4 "aarch64_reg_zero_or_m1_or_1")))]
-  "!((operands[3] == const1_rtx && operands[4] == constm1_rtx)
-     || (operands[3] == constm1_rtx && operands[4] == const1_rtx))"
-  ;; Final two alternatives should be unreachable, but included for completeness
-  {@ [ cons: =0 , 3   , 4   ; attrs: type ]
-     [ r        , rZ  , rZ  ; csel        ] csel\t%<w>0, %<w>3, %<w>4, %m1
-     [ r        , rZ  , UsM ; csel        ] csinv\t%<w>0, %<w>3, <w>zr, %m1
-     [ r        , UsM , rZ  ; csel        ] csinv\t%<w>0, %<w>4, <w>zr, %M1
-     [ r        , rZ  , Ui1 ; csel        ] csinc\t%<w>0, %<w>3, <w>zr, %m1
-     [ r        , Ui1 , rZ  ; csel        ] csinc\t%<w>0, %<w>4, <w>zr, %M1
-     [ r        , UsM , UsM ; mov_imm     ] mov\t%<w>0, -1
-     [ r        , Ui1 , Ui1 ; mov_imm     ] mov\t%<w>0, 1
-  }
-)
-
-;; zero_extend version of above
-(define_insn "*cmovsi_insn_uxtw"
-  [(set (match_operand:DI 0 "register_operand")
-	(zero_extend:DI
-	 (if_then_else:SI
-	  (match_operator 1 "aarch64_comparison_operator"
-	   [(match_operand 2 "cc_register") (const_int 0)])
-	  (match_operand:SI 3 "aarch64_reg_zero_or_m1_or_1")
-	  (match_operand:SI 4 "aarch64_reg_zero_or_m1_or_1"))))]
-  "!((operands[3] == const1_rtx && operands[4] == constm1_rtx)
-     || (operands[3] == constm1_rtx && operands[4] == const1_rtx))"
-  ;; Final two alternatives should be unreachable, but included for completeness
-  {@ [ cons: =0 , 3   , 4   ; attrs: type ]
-     [ r        , rZ  , rZ  ; csel        ] csel\t%w0, %w3, %w4, %m1
-     [ r        , rZ  , UsM ; csel        ] csinv\t%w0, %w3, wzr, %m1
-     [ r        , UsM , rZ  ; csel        ] csinv\t%w0, %w4, wzr, %M1
-     [ r        , rZ  , Ui1 ; csel        ] csinc\t%w0, %w3, wzr, %m1
-     [ r        , Ui1 , rZ  ; csel        ] csinc\t%w0, %w4, wzr, %M1
-     [ r        , UsM , UsM ; mov_imm     ] mov\t%w0, -1
-     [ r        , Ui1 , Ui1 ; mov_imm     ] mov\t%w0, 1
-  }
-)
-
 ;; There are two canonical forms for `cmp ? -1 : a`.
 ;; This is the second form and is here to help combine.
 ;; Support `-(cmp) | a` into `cmp ? -1 : a` to be canonical in the backend.
@@ -5278,105 +4440,6 @@
   [(set_attr "type" "logics_shift_imm")]
 )
 
-(define_insn "clz<mode>2"
-  [(set (match_operand:GPI 0 "register_operand" "=r")
-	(clz:GPI (match_operand:GPI 1 "register_operand" "r")))]
-  ""
-  "clz\\t%<w>0, %<w>1"
-  [(set_attr "type" "clz")]
-)
-
-(define_expand "ffs<mode>2"
-  [(match_operand:GPI 0 "register_operand")
-   (match_operand:GPI 1 "register_operand")]
-  ""
-  {
-    rtx ccreg = aarch64_gen_compare_reg (EQ, operands[1], const0_rtx);
-    rtx x = gen_rtx_NE (VOIDmode, ccreg, const0_rtx);
-
-    emit_insn (gen_aarch64_rbit (<MODE>mode, operands[0], operands[1]));
-    emit_insn (gen_clz<mode>2 (operands[0], operands[0]));
-    emit_insn (gen_csinc3<mode>_insn (operands[0], x, operands[0], const0_rtx));
-    DONE;
-  }
-)
-
-(define_insn "*aarch64_popcount<mode>2_cssc_insn"
-  [(set (match_operand:GPI 0 "register_operand" "=r")
-        (popcount:GPI (match_operand:GPI 1 "register_operand" "r")))]
-  "TARGET_CSSC"
-  "cnt\\t%<w>0, %<w>1"
-  [(set_attr "type" "clz")]
-)
-
-;; The CSSC instructions can do popcount in the GP registers directly through
-;; CNT.  If it is not available then we can use CNT on the Advanced SIMD side
-;; through:
-;; MOV	v.1d, x0
-;; CNT	v1.8b, v.8b
-;; ADDV b2, v1.8b
-;; MOV	w0, v2.b[0]
-
-(define_expand "popcount<mode>2"
-  [(set (match_operand:GPI 0 "register_operand")
-	(popcount:GPI (match_operand:GPI 1 "register_operand")))]
-  "TARGET_CSSC || TARGET_SIMD"
-{
-  if (!TARGET_CSSC)
-    {
-      rtx v = gen_reg_rtx (V8QImode);
-      rtx v1 = gen_reg_rtx (V8QImode);
-      rtx in = operands[1];
-      rtx out = operands[0];
-      if(<MODE>mode == SImode)
-	{
-	  rtx tmp;
-	  tmp = gen_reg_rtx (DImode);
-	  /* If we have SImode, zero extend to DImode, pop count does
-	     not change if we have extra zeros. */
-	  emit_insn (gen_zero_extendsidi2 (tmp, in));
-	  in = tmp;
-	}
-      emit_move_insn (v, gen_lowpart (V8QImode, in));
-      emit_insn (gen_popcountv8qi2 (v1, v));
-      emit_insn (gen_aarch64_zero_extend<mode>_reduc_plus_v8qi (out, v1));
-      DONE;
-    }
-})
-
-(define_insn "clrsb<mode>2"
-  [(set (match_operand:GPI 0 "register_operand" "=r")
-        (clrsb:GPI (match_operand:GPI 1 "register_operand" "r")))]
-  ""
-  "cls\\t%<w>0, %<w>1"
-  [(set_attr "type" "clz")]
-)
-
-(define_insn "@aarch64_rbit<mode>"
-  [(set (match_operand:GPI 0 "register_operand" "=r")
-	(unspec:GPI [(match_operand:GPI 1 "register_operand" "r")] UNSPEC_RBIT))]
-  ""
-  "rbit\\t%<w>0, %<w>1"
-  [(set_attr "type" "rbit")]
-)
-
-;; Split after reload into RBIT + CLZ.  Since RBIT is represented as an UNSPEC
-;; it is unlikely to fold with any other operation, so keep this as a CTZ
-;; expression and split after reload to enable scheduling them apart if
-;; needed.  For TARGET_CSSC we have a single CTZ instruction that can do this.
-
-(define_insn_and_split "ctz<mode>2"
- [(set (match_operand:GPI           0 "register_operand" "=r")
-       (ctz:GPI (match_operand:GPI  1 "register_operand" "r")))]
-  ""
-  { return TARGET_CSSC ? "ctz\\t%<w>0, %<w>1" : "#"; }
-  "reload_completed && !TARGET_CSSC"
-  [(const_int 0)]
-  "
-  emit_insn (gen_aarch64_rbit (<MODE>mode, operands[0], operands[1]));
-  emit_insn (gen_clz<mode>2 (operands[0], operands[0]));
-  DONE;
-")
 
 (define_insn "*and<mode>_compare0"
   [(set (reg:CC_Z CC_REGNUM)
@@ -7607,48 +6670,6 @@
   [(set_attr "length" "0")]
 )
 
-(define_insn "aarch64_fjcvtzs"
-  [(set (match_operand:SI 0 "register_operand" "=r")
-	(unspec:SI [(match_operand:DF 1 "register_operand" "w")]
-		   UNSPEC_FJCVTZS))
-   (clobber (reg:CC CC_REGNUM))]
-  "TARGET_JSCVT"
-  "fjcvtzs\\t%w0, %d1"
-  [(set_attr "type" "f_cvtf2i")]
-)
-
-;; Pointer authentication patterns are always provided.  In architecture
-;; revisions prior to ARMv8.3-A these HINT instructions operate as NOPs.
-;; This lets the user write portable software which authenticates pointers
-;; when run on something which implements ARMv8.3-A, and which runs
-;; correctly, but does not authenticate pointers, where ARMv8.3-A is not
-;; implemented.
-
-;; Signing/Authenticating R30 using SP as the salt.
-
-(define_insn "<pauth_mnem_prefix>sp"
-  [(set (reg:DI R30_REGNUM)
-	(unspec:DI [(reg:DI R30_REGNUM) (reg:DI SP_REGNUM)] PAUTH_LR_SP))]
-  ""
-  "hint\t<pauth_hint_num> // <pauth_mnem_prefix>sp";
-)
-
-;; Signing/Authenticating X17 using X16 as the salt.
-
-(define_insn "<pauth_mnem_prefix>1716"
-  [(set (reg:DI R17_REGNUM)
-	(unspec:DI [(reg:DI R17_REGNUM) (reg:DI R16_REGNUM)] PAUTH_17_16))]
-  ""
-  "hint\t<pauth_hint_num> // <pauth_mnem_prefix>1716";
-)
-
-;; Stripping the signature in R30.
-
-(define_insn "xpaclri"
-  [(set (reg:DI R30_REGNUM) (unspec:DI [(reg:DI R30_REGNUM)] UNSPEC_XPACLRI))]
-  ""
-  "hint\t7 // xpaclri"
-)
 
 ;; Save X30 in the X18-based POST_INC stack (consistent with clang).
 (define_expand "scs_push"
@@ -7820,13 +6841,6 @@
   "msr\\t<fpscr_name>, %0"
   [(set_attr "type" "mrs")])
 
-;; Read into the Floating-point Status or Control Register.
-(define_insn "@aarch64_get_<fpscr_name><GPI:mode>"
-  [(set (match_operand:GPI 0 "register_operand" "=r")
-        (unspec_volatile:GPI [(const_int 0)] GET_FPSCR))]
-  ""
-  "mrs\\t%0, <fpscr_name>"
-  [(set_attr "type" "mrs")])
 
 ;; Define the subtract-one-and-jump insns so loop.c
 ;; knows what to generate.
@@ -7880,58 +6894,9 @@
   [(set_attr "type" "csel")]
 )
 
-;; Like speculation_tracker, but track the inverse condition.
-(define_insn "speculation_tracker_rev"
-  [(set (reg:DI SPECULATION_TRACKER_REGNUM)
-	(unspec:DI [(reg:DI SPECULATION_TRACKER_REGNUM) (match_operand 0)]
-	 UNSPEC_SPECULATION_TRACKER_REV))]
-  ""
-  {
-    operands[1] = gen_rtx_REG (DImode, SPECULATION_TRACKER_REGNUM);
-    output_asm_insn ("csel\\t%1, %1, xzr, %M0", operands);
-    return "";
-  }
-  [(set_attr "type" "csel")]
-)
-
-;; BTI <target> instructions
-(define_insn "bti_noarg"
-  [(unspec_volatile [(const_int 0)] UNSPECV_BTI_NOARG)]
-  ""
-  "hint\t32 // bti"
-  [(set_attr "type" "no_insn")]
-)
-
-(define_insn "bti_c"
-  [(unspec_volatile [(const_int 0)] UNSPECV_BTI_C)]
-  ""
-  "hint\t34 // bti c"
-  [(set_attr "type" "no_insn")]
-)
-
-(define_insn "bti_j"
-  [(unspec_volatile [(const_int 0)] UNSPECV_BTI_J)]
-  ""
-  "hint\t36 // bti j"
-  [(set_attr "type" "no_insn")]
-)
 
-(define_insn "bti_jc"
-  [(unspec_volatile [(const_int 0)] UNSPECV_BTI_JC)]
-  ""
-  "hint\t38 // bti jc"
-  [(set_attr "type" "no_insn")]
-)
 
 ;; Hard speculation barrier.
-(define_insn "speculation_barrier"
-  [(unspec_volatile [(const_int 0)] UNSPECV_SPECULATION_BARRIER)]
-  ""
-  "isb\;dsb\\tsy"
-  [(set_attr "length" "8")
-   (set_attr "type" "block")
-   (set_attr "speculation_barrier" "true")]
-)
 
 ;; Support for __builtin_speculation_safe_value when we have speculation
 ;; tracking enabled.  Use the speculation tracker to decide whether to
@@ -8040,196 +7005,6 @@
   [(set_attr "type" "f_rint<stype>")]
 )
 
-;; Transactional Memory Extension (TME) instructions.
-
-(define_insn "tstart"
-  [(set (match_operand:DI 0 "register_operand" "=r")
-	(unspec_volatile:DI [(const_int 0)] UNSPECV_TSTART))
-   (clobber (mem:BLK (scratch)))]
-  "TARGET_TME"
-  "tstart\\t%0"
-  [(set_attr "type" "tme")]
-)
-
-(define_insn "ttest"
-  [(set (match_operand:DI 0 "register_operand" "=r")
-	(unspec_volatile:DI [(const_int 0)] UNSPEC_TTEST))
-   (clobber (mem:BLK (scratch)))]
-  "TARGET_TME"
-  "ttest\\t%0"
-  [(set_attr "type" "tme")]
-)
-
-(define_insn "tcommit"
-  [(unspec_volatile:BLK [(const_int 0)] UNSPECV_TCOMMIT)
-   (clobber (mem:BLK (scratch)))]
-  "TARGET_TME"
-  "tcommit"
-  [(set_attr "type" "tme")]
-)
-
-(define_insn "tcancel"
-  [(unspec_volatile:BLK
-     [(match_operand 0 "const_int_operand" "n")] UNSPECV_TCANCEL)
-   (clobber (mem:BLK (scratch)))]
-  "TARGET_TME && (UINTVAL (operands[0]) <= 65535)"
-  "tcancel\\t#%0"
-  [(set_attr "type" "tme")]
-)
-
-(define_insn "aarch64_rndr"
-  [(set (match_operand:DI 0 "register_operand" "=r")
-	(unspec_volatile:DI [(const_int 0)] UNSPEC_RNDR))
-   (set (reg:CC_Z CC_REGNUM)
-	(unspec_volatile:CC_Z [(const_int 0)] UNSPEC_RNDR))]
-  "TARGET_RNG"
-  "mrs\t%0, RNDR"
-  [(set_attr "type" "mrs")]
-)
-
-(define_insn "aarch64_rndrrs"
-  [(set (match_operand:DI 0 "register_operand" "=r")
-	(unspec_volatile:DI [(const_int 0)] UNSPEC_RNDRRS))
-   (set (reg:CC_Z CC_REGNUM)
-	(unspec_volatile:CC_Z [(const_int 0)] UNSPEC_RNDRRS))]
-  "TARGET_RNG"
-  "mrs\t%0, RNDRRS"
-  [(set_attr "type" "mrs")]
-)
-
-;; Memory Tagging Extension (MTE) instructions.
-
-(define_insn "irg"
-  [(set (match_operand:DI 0 "register_operand" "=rk")
-	(ior:DI
-	 (and:DI (match_operand:DI 1 "register_operand" "rk")
-		 (const_int -1080863910568919041)) ;; 0xf0ff...
-	 (ashift:DI (unspec:QI [(match_operand:DI 2 "register_operand" "r")]
-		     UNSPEC_GEN_TAG_RND)
-		    (const_int 56))))]
-  "TARGET_MEMTAG"
-  "irg\\t%0, %1, %2"
-  [(set_attr "type" "memtag")]
-)
-
-(define_insn "gmi"
-  [(set (match_operand:DI 0 "register_operand" "=r")
-	(ior:DI (ashift:DI
-		 (const_int 1)
-		 (and:QI (lshiftrt:DI
-			  (match_operand:DI 1 "register_operand" "rk")
-			  (const_int 56)) (const_int 15)))
-		(match_operand:DI 2 "register_operand" "r")))]
-  "TARGET_MEMTAG"
-  "gmi\\t%0, %1, %2"
-  [(set_attr "type" "memtag")]
-)
-
-(define_insn "addg"
-  [(set (match_operand:DI 0 "register_operand" "=rk")
-	(ior:DI
-	 (and:DI (plus:DI (match_operand:DI 1 "register_operand" "rk")
-			  (match_operand:DI 2 "aarch64_granule16_uimm6" "i"))
-		 (const_int -1080863910568919041)) ;; 0xf0ff...
-	 (ashift:DI
-	  (unspec:QI
-	   [(and:QI (lshiftrt:DI (match_dup 1) (const_int 56)) (const_int 15))
-	    (match_operand:QI 3 "aarch64_memtag_tag_offset" "i")]
-	   UNSPEC_GEN_TAG)
-	  (const_int 56))))]
-  "TARGET_MEMTAG"
-  "addg\\t%0, %1, #%2, #%3"
-  [(set_attr "type" "memtag")]
-)
-
-(define_insn "subp"
-  [(set (match_operand:DI 0 "register_operand" "=r")
-	(minus:DI
-	  (and:DI (match_operand:DI 1 "register_operand" "rk")
-		  (const_int 72057594037927935)) ;; 0x00ff...
-	  (and:DI (match_operand:DI 2 "register_operand" "rk")
-		  (const_int 72057594037927935))))] ;; 0x00ff...
-  "TARGET_MEMTAG"
-  "subp\\t%0, %1, %2"
-  [(set_attr "type" "memtag")]
-)
-
-;; LDG will use the 16-byte aligned value of the address.
-(define_insn "ldg"
-  [(set (match_operand:DI 0 "register_operand" "+r")
-	(ior:DI
-	 (and:DI (match_dup 0) (const_int -1080863910568919041)) ;; 0xf0ff...
-	 (ashift:DI
-	  (mem:QI (unspec:DI
-	   [(and:DI (plus:DI (match_operand:DI 1 "register_operand" "rk")
-			     (match_operand:DI 2 "aarch64_granule16_simm9" "i"))
-		    (const_int -16))] UNSPEC_TAG_SPACE))
-	  (const_int 56))))]
-  "TARGET_MEMTAG"
-  "ldg\\t%0, [%1, #%2]"
-  [(set_attr "type" "memtag")]
-)
-
-;; STG doesn't align the address but aborts with alignment fault
-;; when the address is not 16-byte aligned.
-(define_insn "stg"
-  [(set (mem:QI (unspec:DI
-	 [(plus:DI (match_operand:DI 1 "register_operand" "rk")
-		   (match_operand:DI 2 "aarch64_granule16_simm9" "i"))]
-	 UNSPEC_TAG_SPACE))
-	(and:QI (lshiftrt:DI (match_operand:DI 0 "register_operand" "rk")
-			     (const_int 56)) (const_int 15)))]
-  "TARGET_MEMTAG"
-  "stg\\t%0, [%1, #%2]"
-  [(set_attr "type" "memtag")]
-)
-
-;; Load/Store 64-bit (LS64) instructions.
-(define_insn "ld64b"
-  [(set (match_operand:V8DI 0 "register_operand" "=r")
-	(unspec_volatile:V8DI
-	  [(mem:V8DI (match_operand:DI 1 "register_operand" "r"))]
-	    UNSPEC_LD64B)
-  )]
-  "TARGET_LS64"
-  "ld64b\\t%0, [%1]"
-  [(set_attr "type" "ls64")]
-)
-
-(define_insn "st64b"
-  [(set (mem:V8DI (match_operand:DI 0 "register_operand" "r"))
-	(unspec_volatile:V8DI [(match_operand:V8DI 1 "register_operand" "r")]
-	    UNSPEC_ST64B)
-  )]
-  "TARGET_LS64"
-  "st64b\\t%1, [%0]"
-  [(set_attr "type" "ls64")]
-)
-
-(define_insn "st64bv"
-  [(set (match_operand:DI 0 "register_operand" "=r")
-	(unspec_volatile:DI [(const_int 0)] UNSPEC_ST64BV_RET))
-   (set (mem:V8DI (match_operand:DI 1 "register_operand" "r"))
-	(unspec_volatile:V8DI [(match_operand:V8DI 2 "register_operand" "r")]
-	    UNSPEC_ST64BV)
-  )]
-  "TARGET_LS64"
-  "st64bv\\t%0, %2, [%1]"
-  [(set_attr "type" "ls64")]
-)
-
-(define_insn "st64bv0"
-  [(set (match_operand:DI 0 "register_operand" "=r")
-	(unspec_volatile:DI [(const_int 0)] UNSPEC_ST64BV0_RET))
-   (set (mem:V8DI (match_operand:DI 1 "register_operand" "r"))
-	(unspec_volatile:V8DI [(match_operand:V8DI 2 "register_operand" "r")]
-	    UNSPEC_ST64BV0)
-  )]
-  "TARGET_LS64"
-  "st64bv0\\t%0, %2, [%1]"
-  [(set_attr "type" "ls64")]
-)
-
 (define_insn "patchable_area"
   [(unspec_volatile [(match_operand 0 "const_int_operand")
 		     (match_operand 1 "const_int_operand")]
@@ -8243,35 +7018,6 @@
   [(set (attr "length") (symbol_ref "INTVAL (operands[0])"))]
 )
 
-(define_insn "aarch64_save_nzcv"
-  [(set (match_operand:DI 0 "register_operand" "=r")
-	(unspec:DI [(reg:CC CC_REGNUM)] UNSPEC_SAVE_NZCV))]
-  ""
-  "mrs\t%0, nzcv"
-)
-
-(define_insn "aarch64_restore_nzcv"
-  [(set (reg:CC CC_REGNUM)
-	(unspec:CC [(match_operand:DI 0 "register_operand" "r")]
-		   UNSPEC_RESTORE_NZCV))]
-  ""
-  "msr\tnzcv, %0"
-)
-
-;; AdvSIMD Stuff
-(include "aarch64-simd.md")
-
-;; Atomic Operations
-(include "atomics.md")
 
 ;; ldp/stp peephole patterns
 (include "aarch64-ldpstp.md")
-
-;; SVE.
-(include "aarch64-sve.md")
-
-;; SVE2.
-(include "aarch64-sve2.md")
-
-;; SME and extensions
-(include "aarch64-sme.md")
